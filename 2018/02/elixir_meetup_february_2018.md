# Welcome!

## Elixir Sydney

## Bitcoin and Language Boundaries

### February 2018

---

* **Welcome**
* **Housekeeping**
* **Get Paid with Bitcoin** Paul Fioravanti
* **Property Testing in Elixir** Josh Price and Jeff Chan
* **Show us your Code**
* **Hangout** Drinks @ Red Oak

---

# Welcome

## New People

---

# Elixir.Camp

* 16-19 March
* Lord Somers Camp, Melbourne
* Talks & Learning Groups
* Networking & Bonfires
* Get your tickets at https://elixir.camp

---

### YOW Lambda Jam

* 21-23 May, 2018
* CFP open until 18th March 2018
* http://lambdajam.yowconference.com.au/call-for-presentations/
* Day of FP training for new people
* Early Bird tickets available now

---

# Exercism team

* Join friendly folk practicing Elixir (and other languages)

http://exercism.io/teams/elixir-sydney

---

# Jobs

## Looking or Hiring?

---

# StreamData

### Functions to create and combine data generators.

---

# Why do you need Generators?

* generate test data or fixtures
* as the basis of property-based testing

---

# What is a Generator?

* A generator is a `StreamData` struct
* Generators are **infinite** streams that never terminate
* They are also a `Stream` (or a lazy `Enum`)
* Values generated by generators are not unique

---

# StreamData.constant/1

Returns an infinite stream of the given value

```elixir
StreamData.constant(:some_term)
|> Enum.take(3)

#=> [:some_term, :some_term, :some_term]
```

---

# StreamData.integer/0

Starts with small integers and grows the bounds

```elixir
StreamData.integer()
|> Enum.take(10)

#=> [-1, 0, -3, 4, -4, 5, -1, -3, 5, 8]
```

---

# StreamData.list_of/0

```elixir
Enum.take(StreamData.list_of(StreamData.binary()), 3)
#=> [[""], [], ["", "w"]

Enum.take(StreamData.list_of(StreamData.integer(), length: 3), 3)
#=> [[0, 0, -1], [2, -1, 1], [0, 3, -3]]

Enum.take(StreamData.list_of(StreamData.integer(), max_length: 1), 3)
#=> [[1], [], []]
```

---

# Other generator creation Functions

```elixir
Enum.take(StreamData.integer(4..8), 3)
#=> [6, 7, 7]

Enum.take(StreamData.keyword_of(StreamData.integer()), 3)
#=> [[], [sY: 1], [t: -1]]

Enum.take(StreamData.map_of(StreamData.integer(), StreamData.boolean()), 3)
#=> [%{}, %{1 => false}, %{-2 => true, -1 => false}]

Enum.take(StreamData.member_of([:ok, 4, "hello"]), 3)
#=> [4, 4, "hello"]
```

---

# Generators are just Streams

```elixir
StreamData.integer()
|> Stream.filter(& &1 > 0)
|> Stream.map(& &1 * 2)
|> Enum.take(10)

#=> [4, 6, 4, 10, 14, 16, 4, 16, 36, 16]
```

---

# Shrinking

* Shrinking is necessary in property-based testing to reduce the data set
* Wrapper values generated by generators internally are optimized for **shrinking**
* Wrapper values contain a generated value with a way to shrink that value.
* Each generator shrinks in an appropriate way
* `integer` shrinks to lowest int in range
* `bool` shrinks to false
* `list_of/1` shrinks down to the empty list

---

# Shrinking in Property-based testing

* It's important to find the minimal value for which a property fails
* Generated values are often bigger and full of garbage

---

# Composing Generators with bind/2

* 2 element tuples where:
  * first element is a non-empty list
  * second element is a random element from that list

```elixir
StreamData.bind(StreamData.list_of(StreamData.integer(), min_length: 1), fn list ->
  StreamData.bind(StreamData.member_of(list), fn elem ->
    StreamData.constant({list, elem})
  end)
end)
```

---

# What is Property-Based Testing?

* Randomly generate lots of data with StreamData Generators
* Make assertions for each value
* If assertion fails then shrink to minimal data set
* Stop after some time if no failures

---

# Benefits of Property-Based Testing

* Test Automation
* Larger sets of test values
* Find edge cases you couldn't possibly think of
* Exhaustive tests if you run them long enough
* Focus on the properties or invariants of your functions
* Don't have to construct fake test data yourself

---

# Get Started!

* Add `StreamData` package

```elixir
use ExUnitProperties

property "reversing a list doesn't change its length" do
  check all list <- list_of(integer()) do
    assert length(list) == length(:lists.reverse(list))
  end
end
```

---

# ExUnitProperties

* Part of StreamData package
* Macros for property-based testing
* Integrated into ExUnit

---

# check/2 macro

> check(generation_clauses, block)

Check all values generated by `StreamData.integer/0` are integers

```elixir
check all int <- integer() do
  assert is_integer(int)
end
```

---

# Complex example

```elixir
check all int1 <- integer(),
          int2 <- integer(),
          int1 > 0 and int2 > 0,
          sum = int1 + int2 do
  assert sum > int1
  assert sum > int2
end
```

---

# gen/2 macro

> gen(generation_clauses, block)

Syntactic sugar to create generators

```elixir
email_generator = map({binary(), binary()}, fn {left, right} -> left <> "@" <> right end)
gen all name <- binary(),
        email <- email_generator do
  %User{name: name, email: email}
end
```

---

# Demo

https://github.com/jgmchan/streamdata_demo

---

# Resources

* https://blog.pryin.io/first-impressions-of-property-testing-with-stream-data/
* http://andrealeopardi.com/posts/the-guts-of-a-property-testing-library/

---

# What's been happening?

---

# Code Formatter

* Elixir 1.6 codebase is fully formatted
* Lot's of opportunities for contributing to other projects
* https://atom.io/packages/atom-elixir-formatter
* https://github.com/mhinz/vim-mix-format
* https://marketplace.visualstudio.com/items?itemName=sammkj.vscode-elixir-formatter

---

# Talk Ideas?

* Want to hear a topic?
* Want to show off a project you've been working on?
* Want to share some interesting tips or tricks?
* Want to explore a library in more depth?

---

# Topics

---

# Thanks for coming
